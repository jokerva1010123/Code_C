# Лабораторная работа №2

[[_TOC_]]

**Цель работы:** знакомство со статическими одномерными массивами (описание, ввод-вывод, передача в функции), адресной арифметикой и классическими алгоритмами программирования, такими как поиск минимума и максимума, накопление суммы, накопление произведения, вставка и удаление элементов в массиве, сортировка и др. Получение навыков измерения времени выполнения функции и выполнения профилирования программы.

## Задание 1. Вариант 0
Вывести сумму четных элементов массива

**Описание функций:** 

`int array_input(array_t a, size_t size)` - ввод элементов массива длины `size`. Функция возвращает 1, если число корректно введенных элементов совпадает с длиной массива, и 0 в ином случае.

`long array_even_elements_sum(const array_t arr, size_t size)` - возвращает сумму четных элементов массива.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%.

## Задание 2. Вариант 0
Сформировать новый массив из элементов исходного массива. При этом в новый массив
помещаются (копируются) элементы исходного массива, которые больше среднего арифметического его
элементов;

**Описание функций:** 

`int array_input(array_t a, size_t size)` - ввод элементов массива длины `size`. Функция возвращает 1, если число корректно введенных элементов совпадает с длиной массива, и 0 в ином случае.

`double array_avg(const array_t arr, size_t size)` - Подсчет среднего арифметического элементов массива

`size_t array_copy_with_barrier(const array_t src, size_t src_n, array_t dst, double value)` - Копирует элементы из массива src в массив dst, большие, чем value. Возвращает количество скопированных элементов

`void array_output(const array_t a, size_t size)` - вывод на экран элементов массива длиной `size`.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%.

## Задание 3. Вариант 0
Удалите из исходного массива все элементы, которые являются числамипалиндромами

**Описание функций:**

`int array_input(array_t a, size_t size)` - ввод элементов массива длины `size`. Функция возвращает 1, если число корректно введенных элементов совпадает с длиной массива, и 0 в ином случае.

`size_t del_palindromes(array_t arr, size_t size);` - удаляет все палиндромы в массиве arr

`long ispalindrome(long number);` - проверяет, является ли number палиндромом

`long amount_digits(long number);` - подсчитывает количество цифр в числе

`long pow_of_10(long x);` - умножает число на 10^x

`long reverse(long number);` - переворачивает число

`void array_output(const array_t a, size_t size)` - вывод на экран элементов массива длиной `size`.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%.

## Задание 4. Вариант 1
Упорядочите исходный массив по возрастанию вставками

**Описание функций:**

`int array_input(array_t a, size_t size)` - ввод элементов массива длины `size`. Функция возвращает 1, если число корректно введенных элементов совпадает с длиной массива, и 0 в ином случае.

`void array_sort(array_t a, size_t size)` - сортирует массив `arr` вставками по возрастанию.

`void array_output(const array_t a, size_t size)` - вывод на экран элементов массива длиной `size`.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%.

## Задание 5. Вариант 4
Вычислить значение `min(x[0]*x[1], x[1]*x[2],x[2]*x[3], ..., x[n-3]*x[n-2], x[n-2]*x[n-1])`,
где x[i] - элементы массива x из n элементов.

**Описание функций:**

`int input(long *pa_b, const long *pa_e);` - ввод с клавиатуры элементов массива: `pa_b` - указатель на начало массива, `pa_e` - адрес сразу за последним элементом массива. Функция возвращает 1, если число корректно введенных элементов совпадает с длиной массива, и 0 в ином случае.

`void output(const long *pa_b, const long *pa_e);` - печать элементов массива.

`size_t count_distinct(const long *pa_b, const long *pa_e);` - подсчет количество уникальных элементов массива

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%.

## Задание 6
На основе задачи 5 провести сравнение производительности разных способов работы с элементами массива
• использование операции индексации a[i];
• формальная замена операции индексации на выражение *(a + i);
• использование указателей для работы с массивом.

Для этого:
• реализовать функцию, которая выполняет указанное в задаче 5 преобразование массива, используя операцию индексации и количество элементов массива (пусть эта функция называется process_1);
• на основе функции process_1 получить функцию process_2, выполнив замену a[i] на *(a + i);
• реализовать программу для проведения измерений, использовать функцию `gettimeofday()` библиотеки `<sys/time.h>`;
• провести замеры времени.

Проварьировать количество повторов (десятки, сотни) и размер массива (десятки, сотни, тысячи).

Результат работы (время указывается в микросекундах):

|  Количество повторов (N)  | Размер массива | Работа с указателями | a[i] | *(a + i) |
|:---------|:---------|:---------|:---------|:----------|
| 1000000 | 10     | 0   | 0   | 0    |
| 1000000 | 50     | 0   | 0   | 0    |
| 10000   | 100    | 0   | 1   | 3    |
| 50000   | 100    | 0   | 1   | 1    |
| 100000  | 100    | 0   | 1   | 2    |
| 1000000 | 100    | 0   | 1   | 2    |
| 1000    | 500    | 0   | 0   | 15   |
| 10000   | 500    | 1   | 4   | 7    |
| 50000   | 500    | 2   | 6   | 8    |
| 100000  | 500    | 3   | 7   | 9    |
| 1000000 | 500    | 2   | 4   | 7    |
| 1000    | 1000   | 0   | 15  | 15   |
| 10000   | 1000   | 6   | 14  | 23   |
| 50000   | 1000   | 5   | 11  | 16   |
| 100000  | 1000   | 5   | 11  | 20   |
| 500000  | 1000   | 5   | 11  | 16   |
| 1000000 | 1000   | 7   | 13  | 20   |
| 1000    | 5000   | 15  | 46  | 78   |
| 10000   | 5000   | 29  | 69  | 119  |
| 100000  | 5000   | 22  | 47  | 71   |
| 1000000 | 5000   | 22  | 51  | 79   |
| 1000    | 10000  | 31  | 62  | 109  |
| 10000   | 10000  | 48  | 104 | 182  |
| 100000  | 10000  | 58  | 109 | 178  |
| 1000000 | 10000  | 46  | 111 | 179  |
| 100     | 50000  | 250 | 500 | 748  |
| 1000    | 50000  | 186 | 498 | 759  |
| 10000   | 50000  | 256 | 566 | 802  |
| 100000  | 50000  | 187 | 435 | 667  |
| 1000000 | 50000  | 201 | 435 | 662  |
| 10      | 100000 | 0   | 0   | 1562 |
| 100     | 100000 | 313 | 626 | 1407 |
| 1000    | 100000 | 484 | 890 | 1499 |
| 10000   | 100000 | 475 | 989 | 1400 |
| 100000  | 100000 | 402 | 868 | 1313 |

Размер массива влияет на время работы функции. Чем больше размер, тем больше время.

Каждый замер дает разные результаты (случайная погрешность), поэтому для получения более точного результата нужно выполнять несколько замеров времени и затем находить среднее время работы функции.

Самым производительным оказался метод с использованием адресной арифметики. Предполагаю, дело в том, что при использовании адресной арифметики для доступа к элементу нужно применить только одну операцию (операцию разыменования). В то время как при использовании индексации выполняется две операции: получение адреса i-ого элемента массива и затем разыменование.

## Задание 7
Провести профилирование программы, написанной для решения задачи 4.

Чтобы провести профилирование программы, при ее сборке требуется указать ключ `-pg`. Во время выполнения программа записывает данные профилирования в файл, который называется gmon.out. 

После того как результаты профилирования получены, необходимо запустить утилиту gprof для интерпретации результатов. Запуск утилиты gprof выглядит следующим образом:
```
gprof app-name [data-file] [> out-file]
```
Если не указываетcz имя файла с данными (параметр data-file), подразумевается файл gmon.out.

Мои представления о времени работы функции сортировки в принципе совпали с тем, что было получено на практике. Вряд ли было возможно делать предположения о конкретных числах, однако было очевидно, что практически 100% времени работы программы выполняется функция сортировки.

Увеличив количество элементов в массиве до 10000 и выполнив профилирование, я получил, что время работы функции и, соответственно, всей программы увеличилось. Если при 2500 элементах общее время работы составило 0.01 секунд, то при 10000 элементах уже 0.1 секунды, что говорит о том, что асимптотика алгоритма сортировки выбором больше, чем O(n), так как при увеличении размера массива в 4 раза мы получаем увеличение времени работы в 10 раз.

Уменьшив количество элементов до 10, я получил нулевое время работы программы. Скорее всего, это связано с тем, что gprof выдает величины времени с точностью до сотой доли секунды, а программа выполнилась быстрее.

Ключи -O1 -O2 -O3 отвечают за оптимизацию кода.

Увеличив размер массива до 50000 элементов и выполнив профилирование по очереди для каждого из этих ключей и без ключей оптимизации, я получил, что без оптимизации программа работает 2.5 секунд, с ключом -O1 2.07 секунд, с ключом -О2 1.05 секунд и с ключом -О3 тоже 1.05 секунд. Это означает, что чем выше уровень оптимизации, тем больше "упрощается" код и быстрее работает программа. Однако, например, для этой программы достаточно второго уровня, несмотря на то, что ключ -О3 подразумевает еще более сильную оптимизацию. Вероятно, этот ключ целесообразно применять при компиляции более сложных программ и тогда эффект от его использования будет заметен.

# Лабораторная работа №5

[[_TOC_]]

## Часть 1

**Цель:** знакомство с обработкой текстовых и двоичных файлов, получение и закрепление умений открывать файлы в различных режимах, организовывать корректную работу с ресурсами, анализировать информацию об ошибках с помощью функций стандартной библиотеки, использовать в программе аргументы командной строки.

### Задание 1. Вариант 4

Пользователь вводит целые числа, по окончании ввода чисел вводит букву (в Windows для ввода в окне cmd признака EOF можно нажать Ctrl-Z и Enter).

Написать программу, которая находит количество чисел, которые больше своих «соседей», т.е. предшествующего и
последующего;


**Дополнительные требования:**
1. Прототип функции, которая реализует решение задачи, должен выглядеть следующим образом:
```c
int process(FILE *f [, прочие выходные параметры]);
```
2. Функция `process` возвращает 0 в случае успешного решения задачи и отрицательный код ошибки в противном случае (например, -1 – входных данных нет и т.д.). Для каждого кода ошибки задается мнемоническое имя с помощью директивы define.
3. При решении любого варианта задачи 1 два цикла ввода и массивы не использовать.

**Описание функций:**

`int process(FILE *f, size_t *amount)` - реализация решения задачи

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00% для всех файлов.

### Задание 2, Вариант 4
Написать программу, которая считывает из текстового файла вещественные числа и найти среднее значение чисел, расположенных между минимальным и максимальным числами («между» - не по значению, а по расположению); предполагается, что минимум и максимум один.

**Дополнительные требования:**
1. При решении задачи массивы не использовать.
2. Имя файла берется из аргументов командной строки.
3. Предусмотреть обработку ошибок.
4. Решение любой из этих задач выполняется минимум за два просмотра файла. 

**Описание функций:**

`size_t avg(FILE *f, long *start_pos, long *end_pos, double *avg)` - рассчитывает среднее арифметическое

`int min_max_pos(FILE *f, long *pos_min, long *pos_max)` - определеяет позиции максимума и минимума

`void lswap(long *a, long *b)` - меняет элементы типа long местами

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00% для всех файлов.

### Задание 3
Написать программу, которая обрабатывает двоичный файл, содержащий целые числа типа `int`. Программа должна уметь:
• создавать файл и заполнять его случайными числами (аргументы в произвольной форме, например, `app.exe c number file`; создание не проверяется);
• выводить числа из файла на экран (`app.exe p file`);
• упорядочивать числа в файле (`app.exe s file`).

Прежде чем реализовывать функцию упорядочивания файла, необходимо реализовать функцию `get_number_by_pos`, которая по заданной позиции, позволяет прочитать число в указанной позиции, и функцию `put_number_by_pos`, которая позволяет записать число в указанную позицию. Функцию упорядочивания необходимо реализовать с помощью этих функций.

В начале файла, содержащего исходный код программы, должен располагаться
многострочный комментарий, в котором необходимо указать детали реализации этой задачи, как минимум, выбранные целочисленный тип, алгоритм сортировки, «направление» упорядочивания.

**Описание функций:**

`int create_bfile_with_rand_num(FILE *f, size_t amount)` - создает бинарный файл со случайными числами

`int file_size(FILE *f, size_t *size)` - подсчитывает размер файла

`int print_bfile(FILE *f)` - печатает бинарный файл

`int get_number_by_pos(FILE *f, size_t pos, int *number)` - получить число из файла по его позиции

`int put_number_by_pos(FILE *f, size_t pos, int number)` - вставить число в файл на позицию number

`int sort(FILE *f)` - отсортировать файл

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00%

## Часть 2
**Цель:** знакомство со структурами и их использованием. Закрепление умений обрабатывать массивы, строки, текстовые и двоичные файлы, организовывать корректную работу с ресурсами, использовать аргументы командной строки в программе.

### Вариант 1
Задана следующая информация о студентах:
• фамилия (максимум 25 символов);
• имя (максимум 10 символов);
• оценки по четырем предметам (массив, элементы которого имеют тип “целое
беззнаковое длиной 32 бита”).

Написать программу, которая реализует следующие функции:
1. Упорядочивает информацию о студентах по фамилиям. При этом информация о студентах с одинаковой фамилией должна быть упорядочена по имени. Результат выводится на экран. Запуск программы: «`app.exe sb file_in`».

2. Выводит информацию о студентах, фамилия которых начинается с заданной подстроки, в другой файл. Запуск программы: «`app.exe fb file_in file_out substr`».

3. Для каждого студента вычисляет средний балл. Затем вычисляет среднее значение среднего балла и удаляет студентов, средний балл которых меньше среднего значения. Результат записывается в тот же файл. Запуск программы: «`app.exe db file_in_out`».

**Описание функций:**

`int file_correctness(FILE *f)` - проверяет корректность файла f

`int file_size(FILE *f, size_t *size)` - подсчитывает размер файла

`int get_student_by_pos(FILE *f, size_t pos, student_t *st)` - получить запись из файла по ее позиции

`int put_student_by_pos(FILE *f, size_t pos, const student_t *st)` - вставить запись в файл на позицию pos

`int studentcmp(const student_t *a, const student_t *b)` - сравнивает две записи student_t

`int sort_students(FILE *f)` - сортировка файла с записями student_t

`void print_student(const student_t *a)` - печать записи student_t

`int print_students(FILE *f)` - печать всех записей student_t

`int isprefix(const char *str, const char *prefix)` - проверяет, является ли prefix - началом строки str

`int filter_by_surname_prefix(FILE *in, FILE *out, const char *prefix)` - сортировка записей по префиксам фамилий

`double marks_avg(const student_t *st)` - подсчитывает среднее аримфетическое оценок одного студента

`int marks_avg_all(FILE *f, double *value)` - среднее арифметическое оценок всех студентов

`int mvleft(FILE *f, size_t *num_of_students, size_t pos)` - сдвиг влево на 1 запись

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100%
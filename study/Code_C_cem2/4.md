# Лабораторная работа №4

[[_TOC_]]

**Цель работы:** знакомство со строками: реализацией описания строк, их обработкой с помощью функций из стандартной библиотеки и без них, передачей их в функции; знакомство с многофайловыми проектами.

## Задание 1
Самостоятельно реализовать указанные строковые функции.
1. strpbrk
2. strspn
3. strcspn
4. strchr
5. strrchr

Имена функций, которые реализуются самостоятельно, начинаются с префикса “my_” (если нужно реализовать функцию strpbrk, в программе она должна называться my_strpbrk).

**Описание функций:**

`char *my_strpbrk(const char *s1, const char *s2)` - возвращает указатель на первый встретившийся ненулевой символ из строки под указателем `s1`, который встречается в строке под указателем `s2`. Если такого символа не найдено, возвращает `NULL`.

`size_t my_strspn(const char *s1, const char *s2)` - возвращает количество идущих подряд, начиная с первого, символов строки под указателем `s1`, которые содержатся в строке под указателем `s2`.

`size_t my_strcspn(const char *s1, const char *s2)` - возвращает количество идущих подряд, начиная с первого, символов строки под указателем `s1`, которые не содержатся в строке под указателем `s2`.

`char *my_strchr(const char *s, int c)` - возвращает указатель на первое вхождение символа с кодом `c` в строку под указателем `s`. Если символ не найден, возвращает `NULL`.

`char *my_strrchr(const char *s, int c)` - возвращает указатель на последнее вхождение символа с кодом `c` в строку под указателем `s`. Если символ не найден, возвращает `NULL`.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:**
* 100.00% для файла *mystring.c*
* 46.67% для файла *main.c*, так как не использованы операторы, в которых программа сообщает о непройденном модульном тесте.


## Задание 2. Вариант 0
Написать программу, которая запрашивает у пользователя одну строку, разбивает ее на слова и выполняет обработку этих слов. Разбиение строки на слова реализуется самостоятельно (использовать для выделения слов функции scanf, sscanf или strtok нельзя).

**Обработка слов:**  Для каждого слова подсчитать количество его встреч в исходной
строке. Программа должна вывести пары: “слово” “количество встреч” (кавычки не
нужны). Каждая пара выводится на отдельной строке. Слова выводятся в том порядке,
в котором они встретились в исходной строке

Длина строки не превышает 256 символов, длина слова - 16-ти символов. Слова разделяются одним или несколькими пробелами и знаками пунктуации (“,”, “;”, “:”, “-”, “.”, “!”, “?”).

Результаты выводятся обязательно после фразы "Result:" (кавычки не нужны). Слова разделяются одним пробелом. В случае если задача решение не может быть получено, на экран ничего не выводится, возвращается код ошибки.

**Описание функций:**

`int split(char *str, char words[N_MAX][LEN_WORDS + 1], const char delim[], size_t *numofword)` - Разбивает строку str на слова words по разделителям delim. Возвращает код ошибки. Если длина какого-либо слова больше, чем 16 символов, возвращает 0, иначе 1

`size_t skip_delims(const char *str, size_t i, const char delim[])` - Функция пропускает все разделители delim[] в строке str. Возвращает индекс ближайшего следующего символа, который не совпадает ни с одним сиволом из delim[].('/0' - считается сиволом строки.)

`int exist_in(char s, const char *str)` - Функция проверяет, содержится ли символ s в строке str. Возвращает отличное от нуля число, если содержится, и 0 - если нет.

`size_t amount(char words[N_MAX][LEN_WORDS + 1], size_t size, char *word)` - Функция подсчитывает, сколько раз строка word содержится в массиве words. Если строка не содержится в массиве, функция возвращает 0.

Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00% для всех файлов.


## Задание 3. Вариант 0
Для решения этой задачи нужно использовать функции стандартной библиотеки для обработки строк. 

Написать программу, которая запрашивает у пользователя строку, разбивает строку на слова. В результате разбора строки формируется массив слов. 

Максимальные длины строки и слова, разделители слов такие же как в задаче 2. 

Из слов, отличных от последнего, составляется новая строка, в которой слова разделяются одним пробелом. Слова в результирующую строку помещаются в обратном порядке. После последнего слова в результирующей строке пробел не добавляется. 

Прежде, чем очередное слово помещается в результирующую строку, в нем Удалить из слова все последующие вхождения первой буквы. 

Если результирующая строка не пустая, она выводится на экран с помощью вызова функции printf следующим образом:
```c
printf("Result: %s\n", new_str);
```

**Описание функций:**

`int split(char *str, char words[N_MAX][LEN_WORDS + 1], const char delim[], size_t *numofword)` - Разбивает строку str на слова words по разделителям delim. Возвращает код ошибки. Если длина какого-либо слова больше, чем 16 символов, возвращает 0, иначе 1

`void del_all_entries_of_word(char words[N_MAX][LEN_WORDS + 1], size_t *numofwords, char *word)` -  массиве слов words удаляет все вхождения слова word

`void del_duplicates_in_words(char words[N_MAX][LEN_WORDS + 1], size_t numofwords)` - Удаляет все последующие вхождения первого символа во всех словах words

`void rjoin(char words[N_MAX][LEN_WORDS + 1], size_t numofwords, char *str)` - объединить справа налево

`void mvleft(char words[N_MAX][LEN_WORDS + 1], size_t *numofwords, size_t begin)` - Сдвинуть влево массив слов

`void del_first_letter_duplicates(char *word)` - Удаляет все последующие вхождения первой буквы в слове word

`void delete_letter(char *word, size_t index)` - Удаляет вхождения первой буквы


Компиляция программы прошла успешно.

**Результаты анализа покрытия тестами:** 100.00% для всех файлов.